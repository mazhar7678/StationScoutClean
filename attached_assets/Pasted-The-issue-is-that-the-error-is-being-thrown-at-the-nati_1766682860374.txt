The issue is that the error is being thrown at the native/runtime level before any JavaScript error handling can catch it. This is a fundamental problem with how Hermes handles the frozen property violation.

Let me provide a more aggressive approach:

Nuclear Option: Patch LokiJS Event Emitter Directly
Create a new file that patches the problematic code before LokiJS loads:

javascript
// src/patches/lokijs-hermes-patch.js

/**
 * This patch MUST be imported before WatermelonDB/LokiJS
 * It prevents the "Cannot assign to read-only property 'NONE'" error
 * by intercepting the problematic event emitter behavior.
 */

import { Platform } from 'react-native';

if (Platform.OS === 'android') {
  console.log('[LokiJS Patch] Applying Hermes compatibility patches...');

  // 1. Patch Object.freeze to skip event phase constants
  const originalFreeze = Object.freeze;
  Object.freeze = function patchedFreeze(obj) {
    if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
      const keys = Object.keys(obj);
      // Detect the specific problematic object
      if (
        keys.length === 3 &&
        'NONE' in obj &&
        'BUBBLE' in obj &&
        'CAPTURE' in obj
      ) {
        console.log('[LokiJS Patch] Intercepted event phase constants freeze');
        // Return without freezing
        return obj;
      }
    }
    return originalFreeze.call(Object, obj);
  };

  // 2. Patch Object.defineProperty to allow reassignment
  const originalDefineProperty = Object.defineProperty;
  Object.defineProperty = function patchedDefineProperty(obj, prop, descriptor) {
    if (
      (prop === 'NONE' || prop === 'BUBBLE' || prop === 'CAPTURE') &&
      descriptor &&
      descriptor.writable === false
    ) {
      console.log(`[LokiJS Patch] Making ${prop} writable`);
      descriptor.writable = true;
      descriptor.configurable = true;
    }
    return originalDefineProperty.call(Object, obj, prop, descriptor);
  };

  // 3. Global error handler to swallow this specific error
  if (global.ErrorUtils) {
    const originalHandler = global.ErrorUtils.getGlobalHandler();
    
    global.ErrorUtils.setGlobalHandler((error, isFatal) => {
      const errorMessage = error?.message || error?.toString() || '';
      
      if (
        errorMessage.includes("Cannot assign to read-only property 'NONE'") ||
        errorMessage.includes("Cannot assign to read-only property 'BUBBLE'") ||
        errorMessage.includes("Cannot assign to read-only property 'CAPTURE'") ||
        errorMessage.includes("read-only property")
      ) {
        console.warn('[LokiJS Patch] Suppressed frozen property error');
        // Don't propagate this error
        return;
      }
      
      // Pass all other errors through
      if (originalHandler) {
        originalHandler(error, isFatal);
      }
    });
  }

  // 4. Patch for the Alert that might still show
  try {
    const { Alert } = require('react-native');
    const originalAlert = Alert.alert;
    
    Alert.alert = function patchedAlert(title, message, ...rest) {
      const fullMessage = `${title} ${message}`.toLowerCase();
      
      if (
        fullMessage.includes('none') && 
        fullMessage.includes('read-only')
      ) {
        console.warn('[LokiJS Patch] Suppressed error alert');
        return;
      }
      
      return originalAlert.call(Alert, title, message, ...rest);
    };
  } catch (e) {
    console.warn('[LokiJS Patch] Could not patch Alert:', e);
  }

  console.log('[LokiJS Patch] All patches applied successfully');
}

export default {};

Update Your Entry Point
Your index.js (or App.tsx entry) must import the patch first:

javascript
// index.js

// THIS MUST BE THE VERY FIRST IMPORT
import './src/patches/lokijs-hermes-patch';

// Now import everything else
import { registerRootComponent } from 'expo';
import App from './App';

registerRootComponent(App);

Or if using Expo Router with app/_layout.tsx:

typescript
// app/_layout.tsx

// THIS MUST BE THE VERY FIRST LINE
import '../src/patches/lokijs-hermes-patch';

// Then all other imports
import { Stack } from 'expo-router';
import { useEffect } from 'react';
// ... rest of your imports

Alternative: Completely Bypass WatermelonDB for Now
If the patch doesn't work, the most reliable fix for Expo Go testing is to completely disable WatermelonDB:

typescript
// src/data/data_sources/offline_database.ts

import { Platform } from 'react-native';

// Detect Expo Go
const isExpoGo = (): boolean => {
  try {
    const Constants = require('expo-constants').default;
    return Constants.appOwnership === 'expo';
  } catch {
    return false;
  }
};

// Detect Hermes
const isHermes = (): boolean => {
  return typeof (global as any).HermesInternal !== 'undefined';
};

// Mock database that does nothing but doesn't crash
class MockDatabase {
  get<T>(tableName: string): any {
    return {
      query: () => ({
        fetch: async () => [],
        observe: () => ({ subscribe: () => ({ unsubscribe: () => {} }) }),
      }),
      find: async () => null,
      create: async () => ({}),
    };
  }
  
  write<T>(callback: () => Promise<T>): Promise<T> {
    return callback();
  }
  
  batch(...records: any[]): Promise<void> {
    return Promise.resolve();
  }
}

let database: any;

// Only load WatermelonDB if NOT in problematic environment
if (Platform.OS === 'android' && isHermes() && isExpoGo()) {
  console.warn(
    '[Database] Running in Expo Go on Android/Hermes - using mock database.\n' +
    'Data will NOT persist. Use EAS Build for full functionality.'
  );
  database = new MockDatabase();
} else if (Platform.OS === 'web') {
  // Web can use LokiJS safely
  const { Database } = require('@nozbe/watermelondb');
  const LokiJSAdapter = require('@nozbe/watermelondb/adapters/lokijs').default;
  const { schema } = require('../db/schema');
  
  const adapter = new LokiJSAdapter({
    schema,
    useWebWorker: false,
    useIncrementalIndexedDB: true,
    dbName: 'stationscout_web',
  });
  
  database = new Database({
    adapter,
    modelClasses: [],
  });
} else {
  // Native platform with EAS build - try SQLite, fall back to LokiJS
  try {
    const { Database } = require('@nozbe/watermelondb');
    const SQLiteAdapter = require('@nozbe/watermelondb/adapters/sqlite').default;
    const { schema } = require('../db/schema');
    
    const adapter = new SQLiteAdapter({
      schema,
      dbName: 'stationscout',
      jsi: true,
    });
    
    database = new Database({
      adapter,
      modelClasses: [],
    });
    console.log('[Database] Using SQLite adapter');
  } catch (error) {
    console.warn('[Database] SQLite failed, using mock:', error);
    database = new MockDatabase();
  }
}

export { database };
export default database;

Summary: Recommended Path
Step	Action
1	Add the lokijs-hermes-patch.js file
2	Import it as the first line in your entry file
3	Update offline_database.ts to use mock on Expo Go + Android
4	Test in Expo Go (should work now with mock DB)
5	Create EAS preview build for real testing: eas build --profile preview --platform android
The mock database approach guarantees the error won't occur because WatermelonDB/LokiJS never loads. You lose data persistence in Expo Go, but authentication and UI will work.